const std = @import("std");
const c = @import("internal/c.zig");
const internal = @import("internal/internal.zig");
const log = std.log.scoped(.git);

const git = @import("git.zig");

pub const GitError = error{
    /// Generic error
    GenericError,
    /// Requested object could not be found
    NotFound,
    /// Object exists preventing operation
    Exists,
    /// More than one object matches
    Ambiguous,
    /// Output buffer too short to hold data
    BufferTooShort,
    /// A special error that is never generated by libgit2 code.  You can return it from a callback (e.g to stop an iteration)
    /// to know that it was generated by the callback and not by libgit2.
    User,
    /// Operation not allowed on bare repository
    BareRepo,
    /// HEAD refers to branch with no commits
    UnbornBranch,
    /// Merge in progress prevented operation
    Unmerged,
    /// Reference was not fast-forwardable
    NonFastForwardable,
    /// Name/ref spec was not in a valid format
    InvalidSpec,
    /// Checkout conflicts prevented operation
    Conflict,
    /// Lock file prevented operation
    Locked,
    /// Reference value does not match expected
    Modifed,
    /// Authentication error
    Auth,
    /// Server certificate is invalid
    Certificate,
    /// Patch/merge has already been applied
    Applied,
    /// The requested peel operation is not possible
    Peel,
    /// Unexpected EOF
    EndOfFile,
    /// Invalid operation or input
    Invalid,
    /// Uncommitted changes in index prevented operation
    Uncommited,
    /// The operation is not valid for a directory
    Directory,
    /// A merge conflict exists and cannot continue
    MergeConflict,
    /// A user-configured callback refused to act
    Passthrough,
    /// Signals end of iteration with iterator
    IterOver,
    /// Internal only
    Retry,
    /// Hashsum mismatch in object
    Mismatch,
    /// Unsaved changes in the index would be overwritten
    IndexDirty,
    /// Patch application failed
    ApplyFail,
};

/// Transform a `GitError` into the matching `libgit2` error code
pub fn errorToCInt(err: GitError) c_int {
    return switch (err) {
        git.GitError.GenericError => c.GIT_ERROR,
        git.GitError.NotFound => c.GIT_ENOTFOUND,
        git.GitError.Exists => c.GIT_EEXISTS,
        git.GitError.Ambiguous => c.GIT_EAMBIGUOUS,
        git.GitError.BufferTooShort => c.GIT_EBUFS,
        git.GitError.User => c.GIT_EUSER,
        git.GitError.BareRepo => c.GIT_EBAREREPO,
        git.GitError.UnbornBranch => c.GIT_EUNBORNBRANCH,
        git.GitError.Unmerged => c.GIT_EUNMERGED,
        git.GitError.NonFastForwardable => c.GIT_ENONFASTFORWARD,
        git.GitError.InvalidSpec => c.GIT_EINVALIDSPEC,
        git.GitError.Conflict => c.GIT_ECONFLICT,
        git.GitError.Locked => c.GIT_ELOCKED,
        git.GitError.Modifed => c.GIT_EMODIFIED,
        git.GitError.Auth => c.GIT_EAUTH,
        git.GitError.Certificate => c.GIT_ECERTIFICATE,
        git.GitError.Applied => c.GIT_EAPPLIED,
        git.GitError.Peel => c.GIT_EPEEL,
        git.GitError.EndOfFile => c.GIT_EEOF,
        git.GitError.Invalid => c.GIT_EINVALID,
        git.GitError.Uncommited => c.GIT_EUNCOMMITTED,
        git.GitError.Directory => c.GIT_EDIRECTORY,
        git.GitError.MergeConflict => c.GIT_EMERGECONFLICT,
        git.GitError.Passthrough => c.GIT_PASSTHROUGH,
        git.GitError.IterOver => c.GIT_ITEROVER,
        git.GitError.Retry => c.GIT_RETRY,
        git.GitError.Mismatch => c.GIT_EMISMATCH,
        git.GitError.IndexDirty => c.GIT_EINDEXDIRTY,
        git.GitError.ApplyFail => c.GIT_EAPPLYFAIL,
    };
}

/// Get detailed information regarding the last error that occured on *this* thread.
pub fn getDetailedLastError() ?*const DetailedError {
    return @ptrCast(?*const DetailedError, c.git_error_last());
}

/// Clear the last error that occured on *this* thread.
pub fn clearLastError() void {
    c.git_error_clear();
}

pub const DetailedError = extern struct {
    raw_message: [*:0]const u8,
    class: ErrorClass,

    pub const ErrorClass = enum(c_int) {
        NONE = 0,
        NOMEMORY,
        OS,
        INVALID,
        REFERENCE,
        ZLIB,
        REPOSITORY,
        CONFIG,
        REGEX,
        ODB,
        INDEX,
        OBJECT,
        NET,
        TAG,
        TREE,
        INDEXER,
        SSL,
        SUBMODULE,
        THREAD,
        STASH,
        CHECKOUT,
        FETCHHEAD,
        MERGE,
        SSH,
        FILTER,
        REVERT,
        CALLBACK,
        CHERRYPICK,
        DESCRIBE,
        REBASE,
        FILESYSTEM,
        PATCH,
        WORKTREE,
        SHA1,
        HTTP,
        INTERNAL,
    };

    pub fn message(self: DetailedError) [:0]const u8 {
        return std.mem.sliceTo(self.raw_message, 0);
    }

    test {
        try std.testing.expectEqual(@sizeOf(c.git_error), @sizeOf(DetailedError));
        try std.testing.expectEqual(@bitSizeOf(c.git_error), @bitSizeOf(DetailedError));
    }

    comptime {
        std.testing.refAllDecls(@This());
    }
};

comptime {
    std.testing.refAllDecls(@This());
}
